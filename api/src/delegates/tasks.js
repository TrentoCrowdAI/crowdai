const Boom = require('boom');

const db = require(__base + 'db');
const config = require(__base + 'config');
const projectsDelegate = require('./projects');
const itemsDelegate = require('./items');
const jobsDelegate = require('./jobs');

/**
 * Creates a task record.
 *
 * @param {Object} task
 * @returns {Object}
 */
const createTask = (exports.createTask = async task => {
  try {
    let res = await db.query(
      `insert into ${
        db.TABLES.Task
      }(job_id, item_id, worker_id, created_at, data) values($1, $2, $3, $4, $5) returning *`,
      [task.job_id, task.item_id, task.worker_id, new Date(), task.data]
    );
    return res.rows[0];
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation('Error while trying to create task record');
  }
});

const getTaskById = (exports.getTaskById = async id => {
  try {
    let res = await db.query(`select * from ${db.TABLES.Task} where id = $1`, [
      id
    ]);
    //console.log(res)
    return res.rowCount > 0 ? res.rows[0] : null;
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation('Error while trying to fetch record');
  }
});

/**
 * Overrides data column for the given task.
 *
 * @param {Number} id
 * @param {Object} taskData
 */
const updateTask = (exports.updateTask = async (id, taskData) => {
  try {
    let res = await db.query(
      `update ${
        db.TABLES.Task
      } set updated_at = $1, data = $2 where id = $3 returning *`,
      [new Date(), taskData, id]
    );
    return res.rows[0];
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation('Error while trying to update record');
  }
});

/**
 * Returns the task records that the worker has already answered.
 *
 * @param {Number} jobId
 * @param {Number} workerId
 */
const getWorkerTasks = (exports.getWorkerTasks = async (jobId, workerId) => {
  try {
    let res = await db.query(
      `select t.* from ${
        db.TABLES.Task
      } t where t.job_id = $1 and t.worker_id = $2 and (t.data ->> 'answered')::boolean = true`,
      [jobId, workerId]
    );
    return { rows: res.rows, meta: { count: res.rowCount } };
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation(
      "Error while trying to fetch the worker's tasks"
    );
  }
});

/**
 * Returns the number of task records that the worker has already answered.
 *
 * @param {Number} jobId
 * @param {Number} workerId
 */
const getWorkerTasksCount = (exports.getWorkerTasksCount = async (
  jobId,
  workerId
) => {
  try {
    let res = await db.query(
      `select count(t.*) from ${
        db.TABLES.Task
      } t where t.job_id = $1 and t.worker_id = $2 and (t.data ->> 'answered')::boolean = true`,
      [jobId, workerId]
    );
    return Number(res.rows[0].count);
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation(
      "Error while trying to fetch the worker's tasks count"
    );
  }
});

/**
 * Returns the buffer of tasks that the NEXT-TASK API generated for the worker. Or
 * null y if the buffer doesn't exist or is empty.
 *
 * @param {Number} jobId
 * @param {Number} workerId
 */
const getBuffer = (exports.getBuffer = async (jobId, workerId) => {
  try {
    let res = await db.query(
      `select t.item_id, t.data from ${
        db.TABLES.Task
      } t where t.job_id = $1 and t.worker_id = $2 and (t.data ->> 'answered')::boolean = false`,
      [jobId, workerId]
    );

    if (res.rowCount === 0) {
      return null;
    }
    return {
      items: res.rows.map(task => task.item_id),
      criteria: res.rows[0].data.criteria.map(c => c.id)
    };
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation('Error while trying to get the tasks buffer');
  }
});

/**
 * Creates the tasks records based on the output of NEXT-TASK API.
 *
 * @param {Number} jobId
 * @param {Number} workerId
 * @param {Object[]} tasks - The tasks generated by NEXT-TASK API. The format is: {items: [], criteria: []}
 */
const createBuffer = (exports.createBuffer = async (jobId, workerId, tasks) => {
  try {
    db.query('BEGIN');
    let criteria = await projectsDelegate.getCriteriaFromIds(tasks.criteria);
    let items = await itemsDelegate.getItemsFromIds(tasks.items);
    criteria = criteria.map(c => ({
      id: c.id,
      label: c.data.label,
      description: c.data.description
    }));

    for (item of items) {
      await createTask({
        job_id: jobId,
        worker_id: workerId,
        item_id: item.id,
        data: {
          item: {
            title: item.data.title,
            description: item.data.description
          },
          criteria,
          answered: false
        }
      });
    }
    await db.query('COMMIT');
    return await getBuffer(jobId, workerId);
  } catch (error) {
    console.error(error);
    await db.query('ROLLBACK');
    throw Boom.badImplementation('Error while trying to create the buffer');
  }
});

/**
 * Returns a task for the worker.
 *
 * @param {Number} jobId
 * @param {Number} workerId
 * @returns {Object}
 */
const getTaskFromBuffer = (exports.getTaskFromBuffer = async (
  jobId,
  workerId
) => {
  try {
    let res = await db.query(
      `select * from ${
        db.TABLES.Task
      } where job_id = $1 and worker_id = $2 and (data ->> 'answered')::boolean = false order by random() limit 1`,
      [jobId, workerId]
    );
    let task = res.rows[0];
    return await updateTask(task.id, {
      ...task.data,
      start: new Date()
    });
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation('Error while trying to fetch the task record');
  }
});

/**
 * Removes (soft) unfinished tasks.
 *
 * @param {String} uuid - The job's UUID.
 * @param {Number} workerId - The worker's ID.
 */
const cleanBuffer = (exports.cleanBuffer = async (uuid, workerId) => {
  try {
    let job = await jobsDelegate.getByUuid(uuid);
    await db.query(
      `update task set deleted_at = now() where job_id = $1 and worker_id = $2 and (data ->> 'answered')::boolean = false`,
      [job.id, workerId]
    );
  } catch (error) {
    console.error(error);
    throw Boom.badImplementation('Error while trying to clean the buffer');
  }
});
